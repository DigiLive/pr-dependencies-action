import * as core from '@actions/core';
import * as github from '@actions/github';
import { isPullRequest, IssueData } from './types.js';
import { Octokit } from '@octokit/rest';
import { BLOCKED_LABEL } from './config.js';

/**
 * Handles pull request and issue updates by commenting and labeling.
 *
 * Note:<br>
 * GitHub's REST API considers every pull request an issue, but not every issue is a pull request.
 * For this reason, "Issues" endpoints may return both issues and pull requests in the response.
 * You can identify pull requests by the pull_request key.
 *
 * Be aware that the id of a pull request returned from "Issues" endpoints will be an issue id.
 * To find out the pull request id, use the "List pull requests" endpoint.
 */
class IssueUpdater {
  private static readonly SIGNATURE = '<!-- dependency-checker-action -->';
  private readonly octokit: Octokit;
  private readonly context: typeof github.context;
  private readonly issueType: string;

  /**
   * Initializes a new instance.
   *
   * @param {Octokit} octokit - an Octokit instance.
   * @param {typeof github.context} context - the GitHub context for the action.
   *
   * @throws {Error} If the context is missing required information.
   */
  constructor(octokit: Octokit, context: typeof github.context) {
    this.validateContext();

    this.octokit = octokit;
    this.context = context;
    this.issueType = github.context.eventName === 'pull_request' ? 'Pull Request' : 'Issue';
  }

  /**
   * Updates an issue with dependency information.
   *
   * Adds a comment when the issue's dependencies have been changed or resolved.
   * While dependencies are still open, the issue is labeled as blocked.
   *
   * @param {IssueData[]} dependencies - an array of dependencies.
   * @returns {Promise<void>} - a promise that resolves when the update is complete.
   */
  async updateIssue(dependencies: IssueData[]): Promise<void> {
    const { number: issue_number } = this.context.issue;

    core.info(`Updating ${this.issueType} #${issue_number} with ${dependencies?.length || 0} dependencies.`);

    try {
      const hasDependencies = dependencies?.length > 0;
      const newComment = this.createCommentBody(dependencies);
      const lastBotComment = await this.findLastBotComment(issue_number);

      await this.handleDependencyUpdate(hasDependencies, newComment, lastBotComment);

      core.info(`Updating ${this.issueType} #${issue_number} successfully finished.`);
    } catch (error) {
      core.error(`Error updating ${this.issueType}.`);
      throw error;
    }
  }

  /**
   * Handles the dependency update for an issue.
   *
   * If the comment has not changed, it will not update the issue.
   * If the dependencies have changed, it will add a new comment and block the issue.
   * If all dependencies have been resolved, it will add a new comment (if needed) and unblock the issue.
   *
   * @param {boolean} hasDependencies - Whether the issue has any dependencies.
   * @param {string} newComment - The new comment to add to the issue.
   * @param {{body?: string}} lastBotComment - The last bot comment on the issue.
   * @returns {Promise<void>} - A promise that resolves when the update is complete.
   */
  private async handleDependencyUpdate(
    hasDependencies: boolean,
    newComment: string,
    lastBotComment?: { body?: string }
  ): Promise<void> {
    const commentChanged = !lastBotComment || lastBotComment.body !== newComment;

    if (!commentChanged) {
      core.info('  The dependencies have not been changed.');
      await (hasDependencies ? this.addBlockedLabel() : this.removeBlockedLabel());
      return;
    }

    if (hasDependencies) {
      core.info('  The dependencies have been changed. Adding a comment...');
      await this.createComment(newComment);
      await this.addBlockedLabel();
      return;
    }

    core.info(`  All dependencies have been resolved.${lastBotComment ? ' Adding a comment...' : ''}`);
    if (lastBotComment) await this.createComment(newComment);
    await this.removeBlockedLabel();
  }

  /**
   * Finds the last bot comment on an issue.
   *
   * The function searches through the comments of the issue in reverse order, looking for a comment
   * created by the 'github-actions[bot]' user that contains the action's signature.
   * If such a comment is found, it is returned. Otherwise, the function returns undefined.
   *
   * @param {number} issueNumber - the number of the issue.
   * @returns {Promise<{body?: string} | undefined>} - a promise that resolves with the last bot comment.
   */
  private async findLastBotComment(issueNumber: number): Promise<{ body?: string } | undefined> {
    const { owner, repo } = this.context.repo;
    const { data: comments } = await this.octokit.rest.issues.listComments({
      owner,
      repo,
      issue_number: issueNumber,
    });

    return comments
      .slice()
      .reverse()
      .find(
        (comment) => comment.user?.login === 'github-actions[bot]' && comment.body?.includes(IssueUpdater.SIGNATURE)
      );
  }

  /**
   * Creates a comment-body based on the given dependencies.
   *
   * If there are no dependencies, a body with a success message is returned.
   * Otherwise, a body is generated with a list of the blocking dependencies.
   *
   * @param {IssueData[]} dependencies - an array of dependencies.
   * @returns {string} - a comment-body.
   */
  private createCommentBody(dependencies: IssueData[]): string {
    let comment = `${IssueUpdater.SIGNATURE}\n`;

    if (!dependencies?.length) {
      comment += `## ✅ All Dependencies Resolved\n\nThis ${this.issueType} has no blocking dependencies.`;
    } else {
      comment += '## ⚠️ Blocking Dependencies Found\n\n';
      comment += `This ${this.issueType} should not be ${this.issueType === 'Pull Request' ? 'merged' : 'resolved'}`
      comment += ' until the following dependencies are resolved:\n\n';

      dependencies.forEach((dependency) => {
        const dependencyType = isPullRequest(dependency) ? 'PR' : 'Issue';
        comment += `- [${dependencyType} #${dependency.number}](${dependency.html_url}) – ${dependency.title}\n`;
      });
    }

    comment += '\n---\n*This is an automated message. Please resolve the above dependencies, if any.*';
    comment += '\n<!-- DO NOT EDIT THIS COMMENT! IT WILL BREAK THE DEPENDENCY CHECKER. -->';

    core.debug(`Generated comment body: ${comment.substring(0, 50)}...`);
    return comment;
  }

  /**
   * Creates a comment on the issue with the given body.
   *
   * @param {string} comment - the body of the comment.
   * @throws {Error} - if the comment cannot be created.
   */
  private async createComment(comment: string) {
    const { owner, repo } = this.context.repo;
    const { number: issue_number } = this.context.issue;

    core.info(`  Creating a comment on ${this.issueType} #${issue_number}...`);

    try {
      await this.octokit.rest.issues.createComment({
        owner,
        repo,
        issue_number,
        body: comment,
      });
      core.debug('Successfully created a comment.');
    } catch (error) {
      core.error(`Failed to create comment on ${this.issueType} #${issue_number}: ${(error as Error).message}`);
      throw error;
    }
  }

  /**
   * Adds the 'blocked' label to the issue, creating it if it does not exist.
   *
   * @throws {Error} - if adding the label failed.
   */
  private async addBlockedLabel() {
    const { owner, repo } = this.context.repo;
    const { number: issue_number } = this.context.issue;

    core.info(`  Adding ${BLOCKED_LABEL} label...`);

    try {
      await this.octokit.rest.issues.addLabels({
        owner,
        repo,
        issue_number,
        labels: [BLOCKED_LABEL],
      });

      core.debug(`Label operation completed for ${this.issueType} #${issue_number}.`);
    } catch (error) {
      core.error(`Error adding ${BLOCKED_LABEL} label.`);
      throw error;
    }
  }

  /**
   * Removes the 'blocked' label from the issue.
   *
   * @throws {Error} - if removing the label failed.
   */
  private async removeBlockedLabel() {
    const { owner, repo } = this.context.repo;
    const { number: issue_number } = this.context.issue;

    core.info(`  Removing ${BLOCKED_LABEL} label...`);

    try {
      await this.octokit.rest.issues.removeLabel({
        owner,
        repo,
        issue_number,
        name: BLOCKED_LABEL,
      });

      core.debug(`Label operation completed for ${this.issueType} #${issue_number}`);
    } catch (error) {
      if (error instanceof Error && 'status' in error && error.status !== 404) {
        core.error(`Error removing ${BLOCKED_LABEL} label: ${error.message}`);
        throw error;
      }

      core.debug(`${BLOCKED_LABEL} label was not present on ${this.issueType} #${issue_number}, nothing to remove`);
    }
  }

  /**
   * Validates that required parameters are present.
   *
   * @private
   * @throws {Error} If required parameters are missing.
   */
  private validateContext() {
    if (!github.context.repo?.owner || !github.context.repo?.repo || !github.context.issue?.number) {
      throw new Error('Missing required GitHub context information');
    }

    if (!['pull_request', 'issues'].includes(github.context.eventName)) {
      throw new Error(`Event name ${github.context.eventName} given, but 'pull_request' or 'issues' expected.`);
    }
  }
}

export { IssueUpdater };
